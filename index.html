<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>MediaPipe REAL FINAL</title>
<style>
  body { margin:0; background:#000; overflow:hidden; }
  video, canvas {
    position:absolute;
    width:640px;
    height:480px;
  }
  #three {
    position:absolute;
    right:0;
    top:0;
    width:640px;
    height:480px;
  }
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<div id="three"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ================= camera ================= */
const video = document.getElementById("video");
navigator.mediaDevices.getUserMedia({ video: true })
  .then(s => video.srcObject = s);

/* ================= canvas ================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = 640;
canvas.height = 480;

/* ================= Three.js ================= */
const scene = new THREE.Scene();
const cam3 = new THREE.PerspectiveCamera(70, 640/480, 0.1, 100);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(640,480);
document.getElementById("three").appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);
cam3.position.z = 3;

(function threeLoop(){
  requestAnimationFrame(threeLoop);
  renderer.render(scene, cam3);
})();

/* ================= MediaPipe ================= */
let busy = false;
let mode = 0;

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({ maxNumHands:1, modelComplexity:0 });
hands.onResults(r => {
  if (!r.multiHandLandmarks) return;
  const lm = r.multiHandLandmarks[0];
  drawConnectors(ctx, lm, HAND_CONNECTIONS, {color:"#0ff"});
  drawLandmarks(ctx, lm, {color:"#f0f"});

  const tips = [8,12,16,20];
  let open = 0;
  for (const i of tips) if (lm[i].y < lm[i-2].y) open++;
  cube.rotation.y += open >= 3 ? 0.05 : 0;
});

const face = new FaceMesh({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});
face.setOptions({ refineLandmarks:false });
face.onResults(r => {
  if (!r.multiFaceLandmarks) return;
  const lm = r.multiFaceLandmarks[0];
  drawConnectors(ctx, lm, FACEMESH_LIPS, {color:"#f00"});
  const d = Math.abs(lm[13].y - lm[14].y);
  cube.scale.setScalar(d > 0.03 ? 1.5 : 1.0);
});

/* ================= main loop ================= */
async function loop() {
  requestAnimationFrame(loop);

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  if (busy) return;
  busy = true;

  if (mode === 0) {
    await hands.send({ image: video });
  } else {
    await face.send({ image: video });
  }
  mode ^= 1;
  busy = false;
}

video.onloadeddata = () => loop();
</script>

</body>
</html>

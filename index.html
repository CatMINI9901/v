<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>MediaPipe FINAL SAFE</title>
<style>
  body { margin:0; background:#000; overflow:hidden; }
  video, canvas {
    position:absolute;
    width:640px;
    height:480px;
  }
  #three {
    position:absolute;
    right:0;
    top:0;
    width:640px;
    height:480px;
  }
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<div id="three"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ================= basic ================= */
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = 640;
canvas.height = 480;

/* ================= Three.js ================= */
const scene = new THREE.Scene();
const cam3 = new THREE.PerspectiveCamera(70, 640/480, 0.1, 100);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(640,480);
document.getElementById("three").appendChild(renderer.domElement);

const cube = new THREE.Mesh(
  new THREE.BoxGeometry(),
  new THREE.MeshNormalMaterial()
);
scene.add(cube);
cam3.position.z = 3;

function loop3() {
  requestAnimationFrame(loop3);
  renderer.render(scene, cam3);
}
loop3();

/* ================= Hands ================= */
let gesture = "none";
const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});
hands.setOptions({ maxNumHands:1, modelComplexity:0 });

hands.onResults(r => {
  if (!r.multiHandLandmarks) return;
  const lm = r.multiHandLandmarks[0];
  drawConnectors(ctx, lm, HAND_CONNECTIONS, {color:"#0ff"});
  drawLandmarks(ctx, lm, {color:"#f0f"});

  const tips = [8,12,16,20];
  let open = 0;
  for (const i of tips) if (lm[i].y < lm[i-2].y) open++;
  gesture = open >= 3 ? "open" : "fist";

  if (gesture === "open") cube.rotation.y += 0.05;
  if (gesture === "fist") cube.rotation.x += 0.05;
});

/* ================= Face ================= */
const face = new FaceMesh({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});
face.setOptions({ maxNumFaces:1, refineLandmarks:false });

face.onResults(r => {
  if (!r.multiFaceLandmarks) return;
  const lm = r.multiFaceLandmarks[0];
  drawConnectors(ctx, lm, FACEMESH_LIPS, {color:"#f00"});
  const d = Math.abs(lm[13].y - lm[14].y);
  cube.scale.setScalar(d > 0.03 ? 1.5 : 1.0);
});

/* ================= Camera (SAFE) ================= */
let mode = 0;
let lastTime = 0;
const FPS = 15;

const camera = new Camera(video, {
  width: 640,
  height: 480,
  onFrame: async () => {
    const now = performance.now();
    if (now - lastTime < 1000 / FPS) return;
    lastTime = now;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    // 交互に処理（超重要）
    if (mode === 0) {
      await hands.send({image: video});
    } else {
      await face.send({image: video});
    }
    mode ^= 1;
  }
});
camera.start();
</script>

</body>
</html>
